#ifndef CPU_h__
#define CPU_h__

#include <bitset>
#include "Global.h"
#include "IO.h"
#include "APU.h"
#include "PPU.h"
#include "NESGame.h"

class CPU {

private:
	// Registers
	uint8 A, X, Y, SP;

	// Program Counter
	uint16 PC;
	
	// Cycle Counter
	uint64 Cycles;
	
	// Status Flags
	union {
		uint8 raw;
		Bit<0> C; // Carry
		Bit<1> Z; // Zero
		Bit<2> I; // Interrupt toggle
		Bit<3> D; // Decimal mode
		Bit<4> B; // Not used
		Bit<5> X; // Not used
		Bit<6> V; // Overflow
		Bit<7> N; // Negative
	} P;
	
	// Memory
	uint8 RAM[0x800];
	
	// Special flags
	bool Reset, NMI, NMIEdgeDetected, Interrupt;
	
	// Instruction function pointers
	void(CPU::* Ins[0x108])();

	// IO, APU and PPU pointers
	IO* io;
	PPU* ppu;
	APU* apu;
	NESGame* game;
	
	// Helpers
	uint8 Read(uint16 Address);
	uint8 Write(uint16 Address, uint8 Value);
	uint16 WrapAddress(uint16 Old, uint16 New);
	void Misfire(uint16 Old, uint16 New);
	uint8 Pop();
	void Push(uint8 value);

public:	
	CPU();
	void Init();
	void Run();
	void SetAPU(APU* in);
	void SetPPU(PPU* in);
	void SetRAM(uint8 addr, uint8 value) { RAM[addr] = value; }
	void Tick();

	bool Op();
	void Print();
	
	// The following function is modified from Joel Yliluoma's implementation
	template<uint16 op>
	void Instruction()
	{
		uint32 addr=0, d=0, t=0xFF, c=0, sb=0, pbits = op<0x100 ? 0x30 : 0x20;
		const uint32 o8 = op / 32, o8m = 1u << (op%32);
		#define t(w8,w7,w6,w5,w4,w3,w2,w1,w0) if( \
				(o8<1?w0##u : o8<2?w1##u  : o8<3?w2##u : o8<4?w3##u : \
				 o8<5?w4##u : o8<6?w5##u  : o8<7?w6##u : o8<8?w7##u : w8##u) & o8m)

		t(1,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000) { addr = 0xFFFA; }
		t(2,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000) { addr = 0xFFFC; }
		t(4,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000001) { addr = 0xFFFE; }
		t(0,0xFAFFF0FA,0xFAFFF0FA,0xFAFFF0FA,0xFAFFF0FA,0xFAFFF0FA,0xFAFFF0FA,0xFAFFF0FB,0xFAFFF0FA) { addr = Read(PC++); }
		t(0,0xF0F0000A,0xF0F0000A,0x3030000A,0x3030000A,0xF0F0000A,0xF0F0000A,0xF0F0000A,0xF0F0000A) { d = X; }
		t(0,0x0A0E0000,0x0A0E0000,0xCACE0000,0xCACE0000,0x0A0E0000,0x0A0E0000,0x0A0E0000,0x0A0E0000) { d = Y; }
		t(0,0x00F0000A,0x00F0000A,0x00F0000A,0x00F0000A,0x00F0000A,0x00F0000A,0x00F0000A,0x00F0000A) { addr=uint8(addr+d); d=0; Tick(); }
		t(0,0xFA00F000,0xFA00F000,0xFA00F000,0xFA00F000,0xFA00F000,0xFA00F000,0xFA00F001,0xFA00F000) { addr=uint8(addr);   addr+=256*Read(PC++); }
		t(7,0x000E000A,0x000E000A,0x000E000A,0x000E000A,0x000E100A,0x000E000A,0x000E000A,0x000E000B) { addr=Read(c=addr); addr+=256*Read(WrapAddress(c,c+1)); }
		t(0,0x32020000,0x32020000,0xFA0E0000,0x00000000,0x32020000,0x32020000,0x32020000,0x32020000) { Misfire(addr, addr+d); }
		t(0,0xC80C0000,0xC80C0000,0x00000000,0xFA0E0000,0xC80C0000,0xC80C0000,0xC80C0000,0xC80C0000) { Read(WrapAddress(addr, addr+d)); }
		t(0,0x00000000,0xAAAAAAAA,0x00000500,0xAAAAAAAA,0x00000C04,0xAAAAAFAE,0xAAAABEBE,0xAAAAAEAE) { t &= A; }
		t(0,0x00001111,0x00000C00,0x00000000,0xCCCCCCC8,0x00000000,0x00000000,0x00000000,0x00000000) { t &= X; }
		t(0,0x00000000,0x00001111,0x00000000,0x11101111,0x00000000,0x00000000,0x00000000,0x00000000) { t &= Y; }
		t(0,0x00000000,0x00000000,0x0C000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000) { t &= SP; }
		t(7,0x01010000,0x01010000,0x01010000,0x00010000,0x01010000,0x01010000,0x01010000,0x01010101) { t &= P.raw|pbits; c = t; }
		t(0,0x00001011,0xAAAABABB,0x00000000,0x00000000,0x00000000,0xAAAAA2AA,0xAAAAB2BA,0xAAAAA2AA) { c = t; t = 0xFF; }
		t(0,0xEAEEF0FA,0xEAEEF0FA,0xFAFEF0FA,0x00000000,0xEAEEE0EA,0xEAEEE0EA,0xEAEEF0FA,0xEAEEE0EA) { t &= Read(addr+d); }
		t(0,0x00000A05,0x00000A05,0x00000A05,0x00000A05,0x00000A04,0x00000A04,0x00000A04,0x00000A04) { t &= Read(PC++); }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001010,0x00000000) {
			P.V = t & 0x40; P.N = t & 0x80;
		}
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0xC8CCCCCC,0x00000000,0xC8CCC4CC,0x00000000) { sb = P.C; }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000800,0x00000000,0xC8CCCCCC,0xC8CCCCCC) { P.C = t & 0x80; }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0xC8CCC4CC,0xC8CCCCCC,0x00000000,0x00000000) { P.C = t & 0x01; }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xC8CCC4CC,0xC8CCC4CC) { t = (t << 1) | (sb << 0); }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0xC8CCCCCC,0xC8CCCCCC,0x00000000,0x00000000) { t = (t >> 1) | (sb << 7); }
		t(0,0x00000000,0xC8CCC4C8,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000) { t = uint8(t - 1); }
		t(0,0xC8CCC1C8,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000) { t = uint8(t + 1); }
		t(0,0xC8CCC0C8,0xC8CCC0C8,0x00000000,0x22FEF0FA,0xC8CCC0C8,0xC8CCC0C8,0xC8CCC0C8,0xC8CCC0C8) { Write(addr+d, t); }
		t(0,0x00000000,0x00000000,0x00000000,0xD8000000,0x00000000,0x00000000,0x00000000,0x00000000) { Write(WrapAddress(addr, addr+d), t &= ((addr+d) >> 8)); }
		t(7,0xDDDCC5C8,0xDDDCC5C8,0x05000500,0x05000500,0xDDDCC5D9,0xDDDCC5D8,0xDDDCC5C9,0xDDDCD5D9) { Tick(); }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000001,0x00000100,0x00000000) { Tick(); t = Pop(); }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000001,0x00000001,0x00000000,0x00000000) { Read(PC++); PC = Pop(); PC |= (Pop() << 8); }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000) { Read(PC++); }
		t(7,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000001,0x00000001) { d=PC+(op?-1:1); Push(d>>8); Push(d); }
		t(7,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00001000,0x00000001,0x00000001) { PC = addr; }
		t(7,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000101) { Push(t); }
		t(7,0x01010000,0x01010000,0x01010000,0x00010000,0x01010000,0x01010000,0x01010000,0x01010001) { t = 1; }
		t(0,0x01010000,0x01010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00010000) { t <<= 1; }
		t(7,0x01000000,0x01000000,0x01000000,0x00000000,0x01010000,0x01010000,0x00010000,0x00010001) { t <<= 2; }
		t(0,0x00000000,0x00000000,0x01000000,0x00000000,0x00010000,0x00010000,0x00010000,0x00010000) { t <<= 4; }
		t(0,0xAAAAAAAA,0x01000000,0x01000000,0x00000000,0x00000000,0x01000000,0x00000000,0x01000000) { t = uint8(~t); }
		t(7,0x01000000,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x01000000,0xAAAAA2AB) { t = c | t; }
		t(0,0x00010000,0x01010000,0x01010000,0x00010000,0x00010000,0x01010000,0xAAABB2BA,0x01010000) { t = c & t; }
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0xAAAAA2AA,0x00000000,0x00000000) { t = c ^ t; }
		t(0,0x00010000,0x00000000,0x00010000,0x00000000,0x00010000,0x00000000,0x00010000,0x00000000) { if(t)  { Tick(); Misfire(PC, addr = int8(addr) + PC); PC=addr; }; }
		t(0,0x00000000,0x00010000,0x00000000,0x00010000,0x00000000,0x00010000,0x00000000,0x00010000) { if(!t) { Tick(); Misfire(PC, addr = int8(addr) + PC); PC=addr; }; }
		t(0,0xAAAAAAAA,0x00000000,0x00000000,0x00000000,0xAAAAA2AA,0x00000000,0x00000000,0x00000000) { c = t; t += A + P.C; P.V = (c^t) & (A^t) & 0x80; P.C = t & 0x100; }
		t(0,0x00001011,0xAAAABABB,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000) { t = c - t; P.C = ~t & 0x100; }
		t(0,0xAAAAAAAA,0x00000000,0xAAAAAAAA,0x01000C00,0xAAAAAFAE,0xAAAAAEAE,0xAAAAAEAE,0xAAAAAEAE) { A = t; }
		t(0,0x00000100,0x00000C00,0xCCCCCCCC,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000) { X = t; }
		t(0,0x00000000,0x00000100,0x10101111,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000) { Y = t; }
		t(0,0x00000000,0x00000000,0x08000000,0x0C000000,0x00000000,0x00000000,0x00000000,0x00000000) { SP = t; }
		t(7,0x01000000,0x01000000,0x01000000,0x00000000,0x01000000,0x01000001,0x01000100,0x01000001) { 
			P.raw = t & ~0x30;
		}
		t(0,0xEAEEFBFB,0xEAEEFFFB,0xFEFEFFFF,0x01000D00,0xEAEEEFEE,0xEAEEEEEE,0xEAEEEEEE,0xEAEEEEEE) {
			P.N = t & 0x80; 
		}
		t(0,0xEAEEFBFB,0xEAEEFFFB,0xFEFEFFFF,0x01000D00,0xEAEEEFEE,0xEAEEEEEE,0xEAEEFEFE,0xEAEEEEEE) {
			P.Z = uint8(t) == 0; 
		}
		t(0,0x00000000,0x00000000,0x00000000,0x00000000,0x00000800,0x00000000,0x00000000,0x00000000) { P.V = (((t >> 5)+1)&2); }
	}
	void SetIO( IO* i );
	void SetGame( NESGame* g );
};

#endif // CPU_h__
